import matplotlib.pyplot as plt
import dataplotter as dplot
import numpy as np
import math
import copy
import traceback
import sys
import lib_joel as lib

# Timer options:
# from timeit import default_timer as timer
from time import perf_counter as timer

# möjligheter för return, returnera ev allvalues, plotterna
# möjligheter att diska comp ex pga för lång tid eller användarspecifierat


# NOTE: if objgenerator returns a list of lists,
#           each competitor is called with *[sublist] for each sublist
#       if objgenerator returns a list,
#           each competitor is called with *[element] for each element
#       if objgenerator doesn't return a list,
#           each competitor is called with *[obj]

# NOTE: evaluate should be a function that takes a list of lists of whatever the competitors return
#       and returns an array (2-dimensional) of values.
#           E.g each competitor returns an array with 3 values that should be compared and
#           the objectgenerator returns a list of 2 objects that the competitors are called with.
#           This results in 6 values per competitor. If there are 4 competitors, evaluate takes
#           a list of 4 sublists (one per competitor) of these 6 values (per competitor) and turns
#           them into 3 values (one for each value returned by the competitors with a singe call)
#           by for example averageing or selecting the minimum/maximum value.
#       Instead of writing your own function you can use the following strings for default functions
#           'avg': avarage  (avg)
#           'min': minimum
#           'max': maximum
#       If evaluate is a list of functions all will be plotted but with different markers


# NOTE: the objects generated by objgenerator should be reusable or cloned by the
#       optional clone parameter (which can be set to True for default copy function)



####################################################################################################
# COMPARE
####################################################################################################
def compare(competitors, objgenerator=lambda x: x,
            start=int(1), stop=int(1000), evaluate='avg',
            step=lambda x: max([1, int(10**math.log(x, 10) / 2)]),
            reverse=False, ranker=None, show=True, ret=[],
            clone=False, args=[], kwargs=[], **plotkwargs):

    if type(competitors) not in [list, tuple]:
        competitors = [competitors]

    if clone is True:
        clone = copy.deepcopy

    # kwarg handling:
    if ('labels' not in plotkwargs and not reverse) or \
            ('figurelabels' not in plotkwargs and reverse):
        labels = [comp.__name__ for comp in competitors]
        if 'labels' not in plotkwargs and not reverse:
            plotkwargs['labels'] = labels
        if 'figurelabels' not in plotkwargs and reverse:
            plotkwargs['figurelabels'] = labels
    if 'plottype' not in plotkwargs:
        plotkwargs['plottype'] = ['linear', 'loglog']
    if 'maxnbrcolors' not in plotkwargs:
        plotkwargs['maxnbrcolors'] = len(competitors)
    if len(args) == 0:
        args = [()] * len(competitors)
    elif len(args) != len(competitors):
        raise ValueError("args is not of same length as competitors. " +
                         "Tip: you might want to use [[args]]... or [args]...  ...* " +
                         str(len(competitors)))
    if len(kwargs) == 0:
        kwargs = [{}] * len(competitors)
    elif len(kwargs) != len(competitors):
        raise ValueError("kwargs is not of same length as competitors. " +
                         "Tip: you might want to use [kwargs]* " +
                         str(len(competitors)))

    if evaluate == 'avg':
        evaluate = avg_
    elif evaluate == 'min':
        evaluate = min_
    elif evaluate == 'max':
        evaluate = max_
    elif not callable(evaluate):
        raise ValueError("evaluate should be callable or one of 'avg', 'min' and 'max'")

    if not callable(step):
        def step_(x): return step
    else:
        step_ = step

    # Return
    rettemp = {}    # things to return
    if 'allvalues' in ret or 'rank' in ret:
        # alla tider, en specifik längd/storlek på obj per sublist (gammal kommentar)
        rettemp['allvalues'] = []
    if 'allplotvalues' in ret:
        rettemp['allplotvalues'] = []

    # Compare
    i = int(start)
    while i <= stop:
        objs = objgenerator(i)
        if not lib.iterable(objs):
            objs = [[objs]]
        else:
            try:
                if not lib.iterable(objs[0]):
                    objs = [[elem] for elem in objs]
            except IndexError:
                pass
        compvalues = []     # competitors avg tider för given obj-längd/storlek (gammal kommentar)
        for j in range(len(competitors)):
            comp = competitors[j]
            objvalue = []  # comps min tid för olika obj (i objs) (gammal kommentar)
            for obj in objs:
                if clone:
                    obj = clone(obj)
                objvalue.append(comp(*obj, *args[j], **kwargs[j]))
            compvalues.append(objvalue)
        if 'allvalues' in rettemp:
            rettemp['allvalues'].append(compvalues)

        # Plot
        plotvalues = evaluate(compvalues)
        if 'allplotvalues' in rettemp:
            rettemp['allplotvalues'].append(plotvalues)

        if not reverse:
            plotvalues = transpose(plotvalues)

        # Plot
        if i == start:
            plotter = dplot.dataplotter(i, plotvalues, **plotkwargs)
        else:
            plotter.addValues(i, plotvalues)

        temp_step = step_(i)
        if temp_step == 0:
            raise ValueError("step should never return 0")
        i += temp_step
    if show:
        plt.show()

    # Return
    rettemp['success'] = True
    rettemp['message'] = []

    def failure():
        rettemp['success'] = False
        traceback.print_exception(*sys.exc_info())

    try:
        if 'rank' in ret:
            if ranker is None:
                rettemp['rank'] = defaultranker(competitors, rettemp['allvalues'])
            else:
                rettemp['rank'] = ranker(competitors, rettemp['allvalues'])
    except:
        rettemp['message'].append('Failed during ranking')
        failure()

    if 'plotter' in ret:
        rettemp['plotter'] = plotter

    return rettemp


####################################################################################################
# COMPETE
####################################################################################################
def compete(competitors, rep=3, *args, **kwargs):
    def wrap(comp, *args, **kwargs):    # Previously, "comp, bool, *args, **kwargs" (what is bool?)
        for i in range(rep):
            starttime = timer()
            comp(*args, **kwargs)
            stoptime = timer()
            diff = stoptime - starttime
            if i == 0:
                time = diff
            elif diff < time:
                time = diff
        return time

    # Fixa plotkwargs med defaults osv:
    if 'labels' not in kwargs:
        kwargs['labels'] = [comp.__name__ for comp in competitors]

    comps = [(lambda x: lambda *args, **kwargs: wrap(x, *args, **kwargs))(comp) for comp in competitors]
    return compare(comps, *args, **kwargs)


####################################################################################################
# OTHER FUNCTIONS
####################################################################################################
def defaultranker(competitor, allvalues):
    def ranker(comp, competitor, allvalues):
        index = competitor.index(comp)
        return allvalues[-1][index]
    temp = sorted(competitor,
                  key=lambda x: ranker(x, competitor, allvalues))
    temp = [elem.__name__ for elem in temp]
    return temp


def transpose(x):
    x = np.array(x, copy=False, ndmin=2)

    return x.transpose([int(i == 0) + i * (i != 0 and i != 1) for i in range(x.ndim)])


def avg_(x):
    if len(x) == 0:
        return x
    x = np.array(x, copy=False).sum(axis=1) / len(x[0])
    if x.ndim == 1:
        return np.array(x, copy=False, ndmin=2).T
    return x


def min_(x):
    if len(x) == 0:
        return x
    x = np.array(x, copy=False).min(axis=1)
    if x.ndim == 1:
        return np.array(x, copy=False, ndmin=2).T
    return x


def max_(x):
    if len(x) == 0:
        return x
    x = np.array(x, copy=False).max(axis=1)
    if x.ndim == 1:
        return np.array(x, copy=False, ndmin=2).T
    return x


def test1(N):
    temp = np.random.rand(N, N)
    return np.linalg.inv(temp)


def test2(N):
    return N*2


if __name__ == "__main__":
    # most common options:
    # plottype list of "loglog", "linear", "logx" and/or "logy"
    # start (int), size to start at
    # stop (int), size to stop at
    # step (function), return stepsize as a function of current size (logarithmic per default)
    # labels (list of strings), labels for the competitors (to legend)
    # args (list of lists), additional arguments to the competitors
    # objgenerator (function of size), returns objects to use as first argument to competitors. For example, if
    #   you are comparing methods for determining the parity of permutations this would take the length of the
    #   permutation as input and output permutations (either one or several in a list)
    compete([test1, test2], start=10, stop=3000, plottype="loglog", labels=["a", "b"])

    # another example (using functions from lipkin_quasi_spin)
    # compete([eigs_positive, eigs, hamiltonian],
    #         objgenerator= lambda x: x/2, args = [[1]]*3)
